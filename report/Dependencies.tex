In this section we will list and describe the tools used in all levels of abstraction of our system. Additional dependencies can be found in appendix \ref{sec:dependencie}
\subsubsection{Spring Java}
Spring framework offers a set of predefined projects for integration services deployed on the cloud, e.g., spring boot, spring cloud, and spring AOP. Exploring the framework was the main motivation behind choosing it for the backend.
\subsubsection{React}
The frontend of our ITU-MiniTwit system is developed in React. We had only 1 week to refactor a web application with a lot of functionality and the only experience some of us had was in React. We considered using Angular but that is an entire framework - everything is done in a specific way rather than flexible (like in React) and it takes considerable time to learn. Since that was not the goal of the course, we decided not to spend so much time on learning a new framework. We also considered but didn't choose Vue.JS because that is a library, designed to develop only web components (usually) rather than a full web application with state management etc. 

\subsubsection{Go}
For the simulator API we decided to program in Go which is another popular programming language. It's stable and offers good mechanisms for concurrent and parallel developments. We chose Go mostly for the learning process as we find it interesting to explore different tools and technologies in the system. It's also pretty light-weight, which suits the rather simple API.

\subsubsection{MongoDB}
MongoDB is a non SQL open-source document database, non SQL databases are highly flexible, allowing variations in the structure of documents and storing documents that are partially complete. After modelling the entities in the MiniTwit project, it turns out that a big object, including long text, picture or even video, is an option. That said, the decision is to be made between relational databases and document-based No-SQL databases. SQL database stores big files as a blob attached to the file system, however, blob storage in SQL server is limited to 2GB, which is not enough for a system that deals with large amounts of data, clearly MiniTwit will have this possibility in the future. Finally, storing big files in SQL Leads to memory inefficiency since all the data in SQL must go through the memory (RAM) first. Mongo, on the other hand, uses BSON format to store the data in memory and it saves data in a form of a document. One document may not exceed 16MB, which is an acceptable limitation for MiniTwit, and if a document exceeds this limit, GridFS comes to the rescue which is introduced in Mongo 2.1 which is a type of document designed to handle large files that exceed 16MB. Thus, Mongo is chosen over SQL databases.

\subsubsection{GitHub Actions}
GitHub Actions is a tool provided by GitHub for creating a CI/CD pipeline, it helps us automate the process of building, testing and merge of the changes in the code. In our case helps us build a strong pipeline that updates docker images and assist the deployment process as well.

\subsubsection{Azure}
Azure is a cloud provider with solution for all infrastructure problems, providing services in various domains such as compute, analytics, storage and networking. Azure provides a production-ready configurable cluster as PaaS, and it was a perfect choice for the MiniTwit use case since it's a low budget project. Creating Kubernetes from scratch requires at least three VM of a specific type that match the Azure requirement for hosting the master node as well as for the worker node in the node pool. Since this project is running on a studentâ€™s subscription with limited credit, it was not affordable. However, the design for such a self-managed cluster requires a master node to run Kubernetes main functionalities including the API, a worker node to run pods inside which the docker container will run, a public client to be the proxy for interacting with the controller and managing the deployment flow, see the diagram below

\subsubsection{Vagrant}
We choose to deploy our application in a remote server provisioned by Azure using Vagrant. As we create a remote server we understand that Vagrant is a powerful tool for VMs based environment management. With this approach we aim to have a consistent environment for deploying the docker containers in our cloud infrastructure. In choosing vagrant we considered the follows aspect:
\begin{itemize}
    \item Combine the power of virtualization with the reach and scope of Microsoft Azure, the system benefits of both are amplified giving us speed, agility, performance, global presence, security and disaster recovery at scale.
    \item It's a popular tool for VMs based environment management, open source, fairly easy to learn with rich documentation and integration with other tools.
\end{itemize}


